INTENSITY VARIATION CODE: 
// --- Setup for the environment (Required for Node.js/Canvas) ---
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');

// 1. Define staticCanvas (400x400)
const staticCanvas = createCanvas(400, 400);
const ctx_static = staticCanvas.getContext('2d');

// 2. Define the 'static' point (Used by the original distToPoint function, kept for completeness)
const static = { x: staticCanvas.width / 2, y: staticCanvas.height / 2 }; // Center point

// 3. Define the distToPoint function (Kept for completeness, though not used in the new streak logic)
function distToPoint(x1, y1, p2) {
    const dx = x1 - p2.x;
    const dy = y1 - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// Clear the canvas to black (or any background)
ctx_static.fillStyle = 'black';
ctx_static.fillRect(0, 0, staticCanvas.width, staticCanvas.height);

// --- NEW: Background Noise (Small, low-intensity white dots) ---
const NOISE_DOTS = 1000;
ctx_static.fillStyle = 'rgba(255, 255, 255, 0.02)'; // Very low opacity white
for (let i = 0; i < NOISE_DOTS; i++) {
    const x = Math.random() * staticCanvas.width;
    const y = Math.random() * staticCanvas.height;
    ctx_static.fillRect(x, y, 1, 1); // Draw a 1x1 pixel dot
}

// --- Modified Drawing Logic: Draw many random streaks with wider intensity variation and overlapping ---
const NUM_STREAKS = 150; // Increased number for overlapping
for (let i = 0; i < NUM_STREAKS; i++) {
    const x = Math.round(Math.random() * staticCanvas.width);
    const y = Math.round(Math.random() * staticCanvas.height * 0.9); // Start in the top 90%
    const length = 10 + Math.random() * 40; // Streak length between 10 and 50
    
    // Wider random alpha range for more variation, including very low intensity (0.1 to 0.8)
    const alpha = 0.1 + Math.random() * 0.7; 
    
    // Random line width for more noise (1 to 2 pixels)
    const lineWidth = 1 + Math.random();

    // Create a vertical linear gradient for the streak
    const streakGrad = ctx_static.createLinearGradient(x, y, x, y + length);
    // Fades from bright white to transparent
    streakGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`); // Brightest at the top (Pure White)
    streakGrad.addColorStop(0.8, `rgba(255, 255, 255, ${alpha * 0.5})`); // Fading color (Pure White)
    streakGrad.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fully transparent at the bottom

    ctx_static.strokeStyle = streakGrad;
    ctx_static.lineWidth = lineWidth; // Use random line width

    // Draw the vertical line (streak)
    ctx_static.beginPath();
    ctx_static.moveTo(x, y);
    ctx_static.lineTo(x, y + length);
    ctx_static.stroke();
}

// --- Original Crosshair Logic (Kept for completeness) ---
// Draw crosshair lines at a random static point
const s1x = Math.round(staticCanvas.width * Math.random());
const s1y = Math.round(staticCanvas.height * Math.random());
const s1Grad = ctx_static.createRadialGradient(s1x, s1y, 0, s1x, s1y, 20);
s1Grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
s1Grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
ctx_static.strokeStyle = s1Grad;
ctx_static.lineWidth = 1; // Ensure line is visible

// Horizontal line
ctx_static.beginPath();
ctx_static.moveTo(s1x - 4, s1y);
ctx_static.lineTo(s1x + 4, s1y);
ctx_static.stroke();

// Vertical line
ctx_static.beginPath();
ctx_static.moveTo(s1x, s1y - 4);
ctx_static.lineTo(s1x, s1y + 4);
ctx_static.stroke();

// --- Save the output to a file (Required for Node.js/Canvas) ---
const out = fs.createWriteStream(__dirname + '/output.png');
const stream = staticCanvas.createPNGStream();
stream.pipe(out);
out.on('finish', () =>  console.log('The PNG file has been created.'));
Adding Noise Code: 
// --- Setup for the environment (Required for Node.js/Canvas) ---
const { createCanvas, loadImage } = require('canvas');
const fs = require('fs');

// 1. Define staticCanvas (400x400)
const staticCanvas = createCanvas(400, 400);
const ctx_static = staticCanvas.getContext('2d');

// 2. Define the 'static' point (Used by the original distToPoint function, kept for completeness)
const static = { x: staticCanvas.width / 2, y: staticCanvas.height / 2 }; // Center point

// 3. Define the distToPoint function (Kept for completeness, though not used in the new streak logic)
function distToPoint(x1, y1, p2) {
    const dx = x1 - p2.x;
    const dy = y1 - p2.y;
    return Math.sqrt(dx * dx + dy * dy);
}

// Clear the canvas to black (or any background)
ctx_static.fillStyle = 'black';
ctx_static.fillRect(0, 0, staticCanvas.width, staticCanvas.height);

// --- NEW: Background Noise (Small, low-intensity white dots) ---
const NOISE_DOTS = 1000;
ctx_static.fillStyle = 'rgba(255, 255, 255, 0.02)'; // Very low opacity white
for (let i = 0; i < NOISE_DOTS; i++) {
    const x = Math.random() * staticCanvas.width;
    const y = Math.random() * staticCanvas.height;
    ctx_static.fillRect(x, y, 1, 1); // Draw a 1x1 pixel dot
}

// --- Modified Drawing Logic: Draw many random streaks with wider intensity variation and overlapping ---
const NUM_STREAKS = 150; // Increased number for overlapping
for (let i = 0; i < NUM_STREAKS; i++) {
    const x = Math.round(Math.random() * staticCanvas.width);
    const y = Math.round(Math.random() * staticCanvas.height * 0.9); // Start in the top 90%
    const length = 10 + Math.random() * 40; // Streak length between 10 and 50
    
    // Wider random alpha range for more variation, including very low intensity (0.1 to 0.8)
    const alpha = 0.1 + Math.random() * 0.7; 
    
    // Random line width for more noise (1 to 2 pixels)
    const lineWidth = 1 + Math.random();

    // Create a vertical linear gradient for the streak
    const streakGrad = ctx_static.createLinearGradient(x, y, x, y + length);
    // Fades from bright white to transparent
    streakGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha})`); // Brightest at the top (Pure White)
    streakGrad.addColorStop(0.8, `rgba(255, 255, 255, ${alpha * 0.5})`); // Fading color (Pure White)
    streakGrad.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fully transparent at the bottom

    ctx_static.strokeStyle = streakGrad;
    ctx_static.lineWidth = lineWidth; // Use random line width

    // Draw the vertical line (streak)
    ctx_static.beginPath();
    ctx_static.moveTo(x, y);
    ctx_static.lineTo(x, y + length);
    ctx_static.stroke();
}

// --- NEW: Salt and Pepper Noise ---
const NOISE_PIXELS = 4000; // Number of pixels to affect (400*400 = 160000 total)
for (let i = 0; i < NOISE_PIXELS; i++) {
    const x = Math.floor(Math.random() * staticCanvas.width);
    const y = Math.floor(Math.random() * staticCanvas.height);
    
    // 50% chance for white (salt), 50% chance for black (pepper)
    const color = Math.random() < 0.5 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
    
    ctx_static.fillStyle = color;
    ctx_static.fillRect(x, y, 1, 1);
}

// --- Original Crosshair Logic (Kept for completeness) ---
// Draw crosshair lines at a random static point
const s1x = Math.round(staticCanvas.width * Math.random());
const s1y = Math.round(staticCanvas.height * Math.random());
const s1Grad = ctx_static.createRadialGradient(s1x, s1y, 0, s1x, s1y, 20);
s1Grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
s1Grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
ctx_static.strokeStyle = s1Grad;
ctx_static.lineWidth = 1; // Ensure line is visible

// Horizontal line
ctx_static.beginPath();
ctx_static.moveTo(s1x - 4, s1y);
ctx_static.lineTo(s1x + 4, s1y);
ctx_static.stroke();

// Vertical line
ctx_static.beginPath();
ctx_static.moveTo(s1x, s1y - 4);
ctx_static.lineTo(s1x, s1y + 4);
ctx_static.stroke();

// --- Save the output to a file (Required for Node.js/Canvas) ---
const out = fs.createWriteStream(__dirname + '/output.png');
const stream = staticCanvas.createPNGStream();
stream.pipe(out);
out.on('finish', () =>  console.log('The PNG file has been created.'));














Curve Fitting Tool:
// --- Setup for the environment (Required for Node.js/Canvas) ---
const { createCanvas } = require('canvas');
const fs = require('fs');

// 1. Define staticCanvas (400x400)
const W = 400;
const H = 400;
const staticCanvas = createCanvas(W, H);
const ctx_static = staticCanvas.getContext('2d');

// Clear the canvas to black
ctx_static.fillStyle = 'black';
ctx_static.fillRect(0, 0, W, H);

// --- Simulation Setup ---
const NUM_PARTICLES = 50;
const particles = [];
const FLOW_FIELD_STRENGTH = 0.5; // Controls the magnitude of the flow

// Simple Flow Field: Constant downward flow with slight horizontal variation
function getFlowVector(x, y) {
    // Base flow is straight down (0, 1)
    let vx = 0;
    let vy = 1;

    // Add a slight horizontal variation based on x-position (e.g., a gentle swirl)
    // This makes the "curve fitting" concept more relevant
    vx = Math.sin(x / W * Math.PI * 2) * 0.2; // Gentle sine wave variation
    vy = 1 + Math.cos(y / H * Math.PI) * 0.1; // Slight speed variation

    // Normalize and scale the vector
    const magnitude = Math.sqrt(vx * vx + vy * vy);
    vx = (vx / magnitude) * FLOW_FIELD_STRENGTH;
    vy = (vy / magnitude) * FLOW_FIELD_STRENGTH;

    return { vx, vy };
}

// Particle class to hold state
class Particle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.history = [{ x, y }]; // To store the path for the streak
        this.maxHistory = 10; // Length of the streak
        this.alpha = 0.5 + Math.random() * 0.5; // Random alpha for intensity variation
    }

    update() {
        const flow = getFlowVector(this.x, this.y);
        this.x += flow.vx * 5; // Move faster for a visible streak
        this.y += flow.vy * 5;

        // Wrap around the screen
        if (this.y > H) {
            this.y = 0;
            this.x = Math.random() * W; // Reset x randomly
            this.history = [{ x: this.x, y: this.y }];
        }

        // Update history
        this.history.push({ x: this.x, y: this.y });
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        }
    }

    drawStreak() {
        if (this.history.length < 2) return;

        // Draw the streak as a path
        ctx_static.beginPath();
        ctx_static.moveTo(this.history[0].x, this.history[0].y);

        for (let i = 1; i < this.history.length; i++) {
            const p = this.history[i];
            // Use a gradient along the streak for intensity variation
            const alpha = this.alpha * (i / this.history.length);
            ctx_static.strokeStyle = `rgba(100, 255, 255, ${alpha})`;
            ctx_static.lineTo(p.x, p.y);
        }
        ctx_static.lineWidth = 1;
        ctx_static.stroke();
    }

    drawVelocityVector() {
        const p = this.history[this.history.length - 1]; // Current position
        const flow = getFlowVector(p.x, p.y);
        const vectorLength = 20;

        const endX = p.x + flow.vx * vectorLength;
        const endY = p.y + flow.vy * vectorLength;

        // Draw the vector (a simple line for now)
        ctx_static.strokeStyle = 'red'; // Velocity vectors in red
        ctx_static.lineWidth = 2;
        ctx_static.beginPath();
        ctx_static.moveTo(p.x, p.y);
        ctx_static.lineTo(endX, endY);
        ctx_static.stroke();

        // Draw an arrowhead (simple triangle)
        const headlen = 5;
        const angle = Math.atan2(endY - p.y, endX - p.x);
        ctx_static.fillStyle = 'red';
        ctx_static.beginPath();
        ctx_static.moveTo(endX, endY);
        ctx_static.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
        ctx_static.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
        ctx_static.closePath();
        ctx_static.fill();
    }
}

// Initialize particles
for (let i = 0; i < NUM_PARTICLES; i++) {
    particles.push(new Particle(Math.random() * W, Math.random() * H));
}

// Simulate multiple steps to generate visible streaks
const SIMULATION_STEPS = 10;
for (let step = 0; step < SIMULATION_STEPS; step++) {
    particles.forEach(p => p.update());
}

// Draw the final frame
particles.forEach(p => p.drawStreak());
particles.forEach(p => p.drawVelocityVector());


// --- Save the output to a file (Required for Node.js/Canvas) ---
const out = fs.createWriteStream(__dirname + '/output.png');
const stream = staticCanvas.createPNGStream();
stream.pipe(out);
out.on('finish', () =>  console.log('The PNG file was created.'));


